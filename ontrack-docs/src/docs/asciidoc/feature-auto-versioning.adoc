[[auto-versioning]]
=== Auto versioning on promotion

Beside collecting data about the performance of your delivery, Ontrack can in turn use this information to drive other automation processes.

One of these processes that Ontrack can drive is the "auto promotion on promotion", which allows the propagation of versions from one repository to others using quality gates based on Ontrack <<model,promotions>>.

Let's imagine a project `parent` which has a dependency on a `module` expressed through a version property somewhere in a file.

Ideally, whenever the `module` has a new version is a given range, we want this version to be used automatically by the `parent`.

Manually, we can do this of course:

* we update the version in the `parent`
* we perform any needed post-processing like a resolution of locks
* we commit and push the change. Voil√†.

If we put extra automation in the mix, you can define a perfectly valid auto versioning process.

This becomes more complex whenever having a new version of the `module` is not enough of a criteria to have it used. This may be a release which has not been qualified yet by extra quality processes (long running ones maybe).

That's where the concept of <<model,promotion>> in Ontrack can play a very important rule:

* the `module` is promoted
* this starts the following process:
  * Ontrack creates a pull request for the `parent` where the version of the `module` has been changed to the one being promoted
  * any required post processing is performed on this PR
  * when the PR is ready to be merged (with all its controls), it's merged automatically

Result:

* versions are propagated automatically only when "promotion gates" are opened

This is valid from one module to a project, and can be easily extended to a full tree of dependent modules.

The diagram below shows how this works:

image::images/auto-versioning-overview.png[alt="Auto versioning overview"]

[[auto-versioning-not]]
==== When not to use auto versioning

While auto versioning is pretty easy to put in place, it should not be used where traditional dependency management based on locks can be used instead for simple code libraries.

Auto versioning on promotion is however particularly well suited to deal with situations like:

* modular monoliths
* GitOps repositories with fixed versions

[[auto-versioning-settings]]
==== General configuration

Auto versioning is not enabled by default. This can be done in the _Settings > Auto Versioning_.

Three parameters are available:

* _Enabled_ - check to enable auto versioning
* _Audit retention_ - maximum number of seconds to keep non-running audit entries for auto versioning requests (see <<auto-versioning-audit>> for more information)
* _Audit cleanup_ - maximum number of seconds to keep audit entries for auto versioning requests. This time is counted after the retention period for the non-running entries  (see <<auto-versioning-audit>> for more information)

[NOTE]
====
These settings can also be <<casc,configured as code>>. For example using:

[source,yaml]
----
ontrack:
  config:
    settings:
      auto-versioning:
        enabled: true
        auditRetentionDuration: 14d
        auditCleanupDuration: 90d
----
====

[[auto-versioning-queue]]
===== Queue configuration

Ontrack uses queues in RabbitMQ to schedule and process auto versioning events.

By default, one and only one queue, called `auto-versioning.default.1` is available. When the load becomes too important, you can use two mechanisms to scale the auto versioning:

* increase the number of default queues. You can set the `ontrack.extension.auto-versioning.queue.scale` <<configuration-properties-auto-versioning,configuration property>> to a higher number than 1

* create dedicated queues for some projects, see below.

[[auto-versioning-queue-dedicated]]
====== Dedicated queues

For a given Ontrack <<model,project>>, you can setup a dedicated queue, which will be used exclusively for this project (whereas the default queues are shared between all projects).

Use the `ontrack.extension.auto-versioning.queue.projects` <<configuration-properties-auto-versioning,configuration property>> to defined a comma-separated list of projects which must have dedicated queues. For example, using environment variables:

[source,bash]
----
ONTRACK_EXTENSION_AUTO_VERSIONING_QUEUE_PROJECTS=project-one,project-two
----

[[auto-versioning-config]]
==== Branch configuration

TODO

[[auto-versioning-post-processing]]
==== Post processing

In some cases, it's not enough to have only a version being updated into one file. Some additional post-processing may be needed.

For example, if using Gradle or NPM dependency locks, after the version is updated, you'd need to resolve and write the new dependency locks.

The Auto Versioning feature allows you to configure this post-processing.

In the <<auto-versioning-config,branch configuration>>, you can set two properties for each source configuration:

* `postProcessing` - ID of the post-processing mechanism
* `postProcessingConfig` - configuration for the post-processing mechanism

As of now, only two post-processing mechanisms are supported. See the sections below for their respective configurations.

[[auto-versioning-post-processing-github]]
===== GitHub post-processing

You can delegate the post-processing to a GitHub workflow.

TODO

[[auto-versioning-post-processing-jenkins]]
===== Jenkins post-processing

You can delegate the post-processing to a Jenkins job.

There is a global configuration and there are a specific configuration at branch level (in the `postProcessingConfig` <<auto-versioning-config,property>>).

For the global configuration, you can go to _Settings > Jenkins Auto Versioning Processing_ and define the following attributes:

* _Configuration_ - default Jenkins configuration to use for the connection
* _Job_ - default path to the job to launch for the post-processing, relative to the Jenkins root URL (note that `/job/` separators can be omitted)
* _Retries_ - the amount of times we check for successful scheduling and completion of the post-processing job
* _Retry interval_ - the time (in seconds) between two checks for successful scheduling and completion of the post-processing job

The `postProcessingConfig` <<auto-versioning-config,property>> at branch level must contain the following parameters:

|===
|Parameter |Default value |Description

|`dockerImage`
|_Required_
|Docker image defining the environment

|`dockerCommand`
|_Required_
|Command to run in the working copy inside the Docker container

|`commitMessage`
|_Required_
|Commit message for the post processed files. If not defined, a default message will be provided

|`config`
|_Optional_
| Jenkins configuration to use for the connection (optional, using defaults if not specified)

|`job`
|_Optional_
| Path to the job to launch for the post processing (optional, using defaults if not specified)

|`credentials`
|_Optional_
|List of credentials to inject in the command (see below)
|===

Example of such a configuration:

[source,yaml]
----
postProcessing: jenkins
postProcessingConfig:
  dockerImage: openjdk:11
  dockerCommand: ./gradlew dependencies --write-locks
  commitMessage: "Resolving the dependency locks"
----

The Jenkins job must accept the following parameters:

|===
|Parameter |Description

|`REPOSITORY_URI`
|Git URI of the repository to upgrade

|`DOCKER_IMAGE`
|This image defines the environment for the upgrade command to run in.

|`DOCKER_COMMAND`
|Command to perform the upgrade.

|`COMMIT_MESSAGE`
|Commit message to use to commit and push the upgrade.

|`UPGRADE_BRANCH`
|Branch containing the code to upgrade.

|`CREDENTIALS`
|Pipe (|) separated list of credential entries to pass to the command.

|===

The Jenkins job is responsible to:

* running a Docker container based on the `DOCKER_IMAGE` image
* inject any credentials defined by `CREDENTIALS` parameter
* checkout the `UPGRADE_BRANCH` branch of the repository at `REPOSITORY_URI` inside the container
* run the `DOCKER_COMMAND` command inside the container
* commit and push any change using the `COMMIT_MESSAGE` message to the `UPGRADE_BRANCH` branch

[[auto-versioning-pr]]
==== Pull requests

After a branch is created to hold the new version, after this branch has been optionally post-processed, Ontrack will create a pull request from this branch to the initial target branch.

The fate of this pull request depends on the _auto approval mode_ which has been set in the <<auto-versioning-config,branch configuration>>:


|===
|Auto approval mode |Description |Pro's |Con's

|`CLIENT`
a|This is the default behaviour. Ontrack takes the ownership of the pull request lifecycle:

* PR is approved automatically
* Ontrack waits for the PR to become mergeable
* Ontrack merges the PR
a|
* Full visibility on the PR lifecycle within Ontrack
a|
* This creates additional load on Ontrack

|`SCM`
a|Ontrack relies on the SCM (GitHub for example) for the lifecycle of the pull request, in a "fire and forget" mode:

* PR is approved automatically
* PR is set for auto merge
* In the background, the PR will be merged automatically once all the conditions are met, but Ontrack does not follow that up
a|
* Less load on Ontrack since the PR lifecycle is fully managed by the SCM
a|
* Less visibility on the PR lifecycle from Ontrack

|===

[[auto-versioning-audit]]
==== Audit logs

TODO
